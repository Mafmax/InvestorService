# InvestorService 

***

## Руководство пользователя
Текущее руководство содержит краткую информацию о продукте и типичные примеры использования 

Приложение представляет собой web API для инвесторов. Позволяет искать активы, хранить сделки в одном или нескольких инвестиционных портфелях.
Структура приложения строится с использованием [сlean architecture](https://habr.com/ru/post/493430/) и содержит в себе следующий набор проектов:
1. Api - Входная точка приложения. Здесь находятся контроллеры, внедряются зависимости и настраивается работа с оркестратором контейнеров.
2. Services - Содержит набор команд (commands), запросов (queries) и их обработчиков (handler). Применяется принцип [CQRS](https://habr.com/ru/company/simbirsoft/blog/329970/) для программного отделения команд, изменяющих данные и запросов, призванных только читать данные. Такой подход позволяет использовать разные хранилища для чтения и записи, что может поспособствовать производительности. В этом же проекте располагаются объекты транспортировки данных (DTO и RequestDTO) изолирующие схему БД и схему команд (запросов).
3. Model - Здесь располагаются все сущности предметной области приложения, их конфигурация и основной контекст базы данных.
4. Model.Migrations - Проект с миграциями схемы БД
5. Services.MockData - вспомогательный для тестирования проект. Содержит классы для работы с фейковыми данными.
6. Services.Test - Проект с тестами основных сущностей приложения.

Все открытые члены проектов Model, Api и Services покрыты документирующими XML комментариями, что поможет узнать принципы работы приложения в деталях. Мы же не будем останавливаться на этом и рассмотрим типовой пример использования приложения.

## Типовой сценарий использования
Допустим, пришла задача добавить еще одну конечную точку в приложение, выполняющую некий запрос. Пусть предметная область новой конечной точки не пересекается с уже имеющимися.
Рассмотрим алгоритм действий:

  1. В проекте Model реализовать класс сущности (ExampleEntity) и добавить ее в контекст.
  
  2. В проекте Services в папке DTOs добавить объект, который будет возвращаться запросом (ExampleDto). Затем в папке Profiles настроить маппинг сущности на DTO (в простейшем случае CreateMap<ExampleEntity,ExampleDto>();).
     
  3. В папке Queries необходиом добавить папку, отражающую новую предметную область (например, Examples). Затем необходимо создать запись (или обычный класс) и назвать его по типу действия плюс Query (например, GetExamplesQuery) и реализовать интерфейс IRequest<TResult>, где TResult - тип, возвращаемого запросом значения (например, IRequest<ExampleDto[]>). Если запрос или команда (что характернее) не должны возвращать значения, то следует ограничиться интерфейсом IRequest. Новая запись (класс) должна содержать только данные для отправки обработчику запросов.

  4. Данные из предыдущего запроса будут получаться из строки запроса пользователя. Если запрос содержит данные, которые необходимо получить программно, то по пути DTOs > RequestDTOs > Queries необходимо расположить запись (класс), инкапсулирующий данные. Название записи следует выбрать по шаблону <QueryName>RequestDto (например, GetExamplesQueryRequestDto) и реализовать метод GetQuery, получающий дополнительные данные и возвращающий экземпляр запроса.
 
  5. Далее нужно создать обработчик этого запроса. Для этого нужно создать по пути Queries > Handlers класс с шаблоном названия <предметная область>QueriesHandler и унаследовать его от класса ServiceBase<TContext>, где TContext - тип контекста, с которым будет производить действия обработчик. Чтобы обработчик стал обработчиком, нужно реализовать интерфейс IRequestHandler<TQuery, TResult>, где TQuery - тип недавно созданного запрос, а TResult - тип возвращаемого запросом результата (например, IRequestHandler<GetExamplesQuery, ExampleEntity[]>). Если возвращаемое значение не предусмотрено, то его можно опустить. Интерфейс определяет метод для обработки запроса Task<TResult> Handle<TResult>(IQuery<TResult> query), в котором необходимо реализовать логику выполнения запроса. В случае отсутствия возвращаемого значения TResult эквивалентно Unit и возвращать следует Unit.Value;
  
  6. В проекте Api в папке Controllers необходимо создать новый класс контроллера (например, ExamplesController), унаследовать от абстрактного класса InvestorServiceControllerBase и добавить конечную точку, например: public async Task<ActionResult<ExamplesDto[]>> GetExamples([FromQuery] GetExamplesQueryRequestDto queryDto), где необходимо выполнить запрос: await Mediator.Send(queryDto.GetQuery(/\*additional info\*/))
  
  7. После этого необходимо написать OpenAPI спецификацию для класса контроллера и провести тестирование обработчика.